<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>谈谈Java弱引用（下）</title>
      <link href="/archives/39e22680.html"/>
      <url>/archives/39e22680.html</url>
      
        <content type="html"><![CDATA[<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>在计算机科学中，<strong>内存泄漏</strong>指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该内存之前就失去了对该段内存的控制，从而造成了内存的浪费。（维基百科）</p><p>在Java中，设计了垃圾回收器进行自动回收垃圾，而不在需要我们手动进行内存释放，给我们编程带来了便捷，但同时也使得内存泄漏更加隐蔽。</p><h3 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h3><p>在编程过程中，我们在内存中申请一块区域进行创建对象，在使用完成之后，我们希望这块内存可以立即被回收掉，这是我们的理想情况，但是GC线程的优先级别很低，同时JVM调用GC的策略也有所不同，就存在引用在内存中包含对象的时间长于预期的存活时间的情况，这样就可能出现内存泄漏。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 内存泄漏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈Java弱引用（上）</title>
      <link href="/archives/eee3a181.html"/>
      <url>/archives/eee3a181.html</url>
      
        <content type="html"><![CDATA[<h2 id="引用概述"><a href="#引用概述" class="headerlink" title="引用概述"></a>引用概述</h2><p>在Java中，存在着四种引用类型，它们按照由强到弱依次是：强引用、软引用、弱引用、虚引用，我们可以用不用的引用来更加了灵活的控制对象的生命周期。</p><h3 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h3><p>类型共有四种，分别是：</p><ul><li>强引用（StrongReference）：最常见的引用，如果一个对象拥有强引用，那GC不会对它进行回收，虚拟机宁愿抛出OutOfMemoryError错误，也不会来回收具有强引用的对象来达到解决内存不足的目地。<br><code>（Object obj = new Object()）</code></li><li>软引用（SoftReference）：如果一个对象拥有软引用，并且内存足够，GC就不会回收它，而在内存不足时，就是回收这个对象的内存。只要GC没有回收它，该对象就可以被程序使用，可以通过软引用来实现缓存的功能<br><code>（SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(new Object())//sf就是软引用，可以通过sf.get()获取该对象，若对象被回收了，则获取到的是null）</code></li><li>弱引用（WeakReference）： 在GC时，无论内存是否足够，均会被回收，不过垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只有弱引用的对象<br><code>（WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(new Object())//wf就是弱引用，GC回收后获取到null）</code></li><li>虚引用（PhantomReference）：虚在这里的意思就是“<strong>形同虚设</strong>”，虚引用不会觉得对象的生命周期，如果一个对象仅持有虚引用，那么就和没有引用一样。虚引用主要用来跟踪垃圾回收器的活动，因为虚引用一般跟引用队列一起使用，回收对象前，将这个虚引用加入这个歌引用队列中，从而记录它指向的对象已经被回收。</li></ul><h2 id="弱引用介绍"><a href="#弱引用介绍" class="headerlink" title="弱引用介绍"></a>弱引用介绍</h2><p>WeakReference类位于java.lang.ref下：</p><pre class="line-numbers language-[java]"><code class="language-[java]">public class WeakReference<T> extends Reference<T> {    /**     * Creates a new weak reference that refers to the given object.  The new     * reference is not registered with any queue.     *     * @param referent object the new weak reference will refer to     */    public WeakReference(T referent) {        super(referent);    }    /**     * Creates a new weak reference that refers to the given object and is     * registered with the given queue.     *     * @param referent object the new weak reference will refer to     * @param q the queue with which the reference is to be registered,     *          or <tt>null</tt> if registration is not required     */    public WeakReference(T referent, ReferenceQueue<? super T> q) {        super(referent, q);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个构造方法的区别是第二个构造方法中加入了ReferenceQueue的引用队列，当这个引用被回收后，就会将其加入到这个引用队列中。</p><h3 id="WeakReference-T-referent"><a href="#WeakReference-T-referent" class="headerlink" title="WeakReference(T referent)"></a>WeakReference(T referent)</h3><p>基础类User</p><pre class="line-numbers language-[java]"><code class="language-[java]">@Data@AllArgsConstructorpublic class User{    private String name;    private int age;    @Override    protected void finalize() throws Throwable    {        System.out.println("开始GC");        super.finalize();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继承WeakReference<User>的UserRef：</p><pre class="line-numbers language-[java]"><code class="language-[java]">public class UserRef extends WeakReference<User>{    public UserRef(User referent)    {        super(referent);    }    public UserRef(User referent, ReferenceQueue<? super User> q)    {        super(referent, q);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>WeakReferenceDemo的dome1：</p><pre class="line-numbers language-[java]"><code class="language-[java]">public class WeakReferenceDemo{    public static void main(String[] args)    {        dome1();        //dome2();        //dome3();    }    private static void dome1()    {        //user是强引用，GC不回收        User user = new User("huang", 20);        UserRef userRef = new UserRef(user);        UserRef userRef2 = new UserRef(new User("zhangsan", 18));        UserRef userRef3 = new UserRef(new User("lisi", 25));        System.out.println(userRef.get());        System.out.println(userRef2.get());        System.out.println(userRef3.get());        System.out.println("-----请求GC-----");        System.gc();        try        {            Thread.sleep(1000);        } catch (InterruptedException e)        {            e.printStackTrace();        }        //回收的是User        System.out.println(userRef);        System.out.println(userRef2);        System.out.println(userRef3);        System.out.println(userRef.get());        System.out.println(userRef2.get());        System.out.println(userRef3.get());    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre><code>User(name=huang, age=20)User(name=zhangsan, age=18)User(name=lisi, age=25)-----请求GC-----开始GC开始GCcom.hq.test.UserRef@5aaa6d82Disconnected from the target VM, address: &#39;127.0.0.1:56573&#39;, transport: &#39;socket&#39;com.hq.test.UserRef@73a28541com.hq.test.UserRef@6f75e721User(name=huang, age=20)nullnull</code></pre><p>可以看到GC只回收弱引用</p><h3 id="WeakReference-T-referent-ReferenceQueue-lt-super-T-gt-q"><a href="#WeakReference-T-referent-ReferenceQueue-lt-super-T-gt-q" class="headerlink" title="WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q)"></a>WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q)</h3><p>dome2</p><pre class="line-numbers language-[java]"><code class="language-[java]"> private static void dome2()    {        ReferenceQueue queue = new ReferenceQueue();        UserRef userRef2 = new UserRef(new User("zhangsan", 18), queue);        UserRef userRef3 = new UserRef(new User("lisi", 25), queue);        System.out.println(userRef2.get());        System.out.println(userRef3.get());        Reference<? extends User> reference = null;        while ((reference = queue.poll())!=null){            //还没有GC,队列中没有值不会有输出            System.out.println("队列中的值:" + reference);        }        System.out.println("-----请求GC-----");        System.gc();        try        {            Thread.sleep(1000);        } catch (InterruptedException e)        {            e.printStackTrace();        }        System.out.println(userRef2);        System.out.println(userRef3);        System.out.println(userRef2.get());        System.out.println(userRef3.get());        while ((reference = queue.poll())!=null){            System.out.println("队列中的值:" + reference);        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在main方法中运行方法dome2</p><p>输出：</p><pre><code>User(name=zhangsan, age=18)User(name=lisi, age=25)-----请求GC-----开始GC开始GCDisconnected from the target VM, address: &#39;127.0.0.1:56582&#39;, transport: &#39;socket&#39;com.hq.test.UserRef@5aaa6d82com.hq.test.UserRef@73a28541nullnull队列中的值:com.hq.test.UserRef@5aaa6d82队列中的值:com.hq.test.UserRef@73a28541</code></pre><p>可以看到被回收的弱引用对象加到了队列中</p><pre class="line-numbers language-[java]"><code class="language-[java]">  private static void dome3()    {        ReferenceQueue queue = new ReferenceQueue();        UserRef userRef2 = new UserRef(new User("zhangsan", 18), queue);        UserRef userRef3 = new UserRef(new User("lisi", 25), queue);        System.out.println(userRef2.get());        //clear方法手动清除        userRef2.clear();        //已经被clear方法清除了,get到null值        System.out.println(userRef2.get());        System.out.println(userRef3.get());        Reference<? extends User> reference = null;        while ((reference = queue.poll())!=null){            //还没有GC,队列中没有值不会有输出            System.out.println("队列中的值:" + reference);        }        System.out.println("-----请求GC-----");        System.gc();        try        {            Thread.sleep(1000);        } catch (InterruptedException e)        {            e.printStackTrace();        }        System.out.println(userRef2);        System.out.println(userRef3);        System.out.println(userRef2.get());        System.out.println(userRef3.get());        while ((reference = queue.poll())!=null){            System.out.println("队列中的值:" + reference);        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在main方法中运行方法dome3</p><p>输出：</p><pre><code>User(name=zhangsan, age=18)nullUser(name=lisi, age=25)-----请求GC-----开始GC开始GCDisconnected from the target VM, address: &#39;127.0.0.1:56594&#39;, transport: &#39;socket&#39;com.hq.test.UserRef@5aaa6d82com.hq.test.UserRef@73a28541nullnull队列中的值:com.hq.test.UserRef@73a28541</code></pre><p>这里可以看出队列中只有一个值了</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda简介</title>
      <link href="/archives/14747.html"/>
      <url>/archives/14747.html</url>
      
        <content type="html"><![CDATA[<h2 id="lambda概述"><a href="#lambda概述" class="headerlink" title="lambda概述"></a>lambda概述</h2><p>同其他编程语言相比，在Java8之前，Java缺少了高效的并行操作，使得编写并发程序的代码非常臃肿，所以在Java8中，借鉴了函数式编程的思想引入了lambda表达式，lambda是一种匿名函数。通俗点讲，它没有声明的方法，也就没有访问的修饰符、返回值声明和名字，让代码更加紧凑高效和易于阅读。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>(parameters)-&gt;{statements} </p><p>or</p><p>(parameters)-&gt;statements</p><p>or</p><p> (parameters)-&gt;expression</p><p>eg：</p><pre class="line-numbers language-[java]"><code class="language-[java]">//无参函数() -> 8；//两个参数函数，返回它们的和,一行代码的话可以去掉花括号{}(a，b) -> a+b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lambda使用"><a href="#lambda使用" class="headerlink" title="lambda使用"></a>lambda使用</h2><p>我们可以使用lambda表达式来替换匿名类，这里使用Runable来举例：</p><pre class="line-numbers language-[java]"><code class="language-[java]">//java8之前new Thread(new Runnable()        {            @Override            public void run()            {                System.out.println("hello world");            }        }).start();//java8new Thread(()-> System.out.println("hello world")).start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以明显的看到代码精简了很多，而且更加方便阅读，在这里我们看不到run方法了，这是因为在Runable接口下只有一个方法的原因，如果有多个，匿名函数是没有办法来区分的。</p><pre class="line-numbers language-[java]"><code class="language-[java]">@FunctionalInterfacepublic interface Runnable {    public abstract void run();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用<strong>@FunctionalInterface</strong>来声明该接口是函数式接口，就是说在这个接口中<strong>只能有一个抽象方法</strong>，如果我们在接口中定义了两个抽象方法，开发工具会对编译级错误检查进行报错的。我们可以利用@FunctionalInterface注解在多个接口的大型项目中控制接口，让其无法添加其他的抽象方法。<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://res.cloudinary.com/dikqccyyc/image/upload/v1577881736/functionalInterface_af5vfo.png" alt="编译级错误"></p><p>JDK中函数式接口例子：</p><ul><li>java.lang.Runable</li><li>java.util.concurrent.Callable</li><li>java.util.Comparator</li><li>java.util.function包下的接口,如Function，Consumer，Predicate，Supplier</li></ul><h3 id="不要将lambda表达式视为内部类"><a href="#不要将lambda表达式视为内部类" class="headerlink" title="不要将lambda表达式视为内部类"></a>不要将lambda表达式视为内部类</h3><p>在前面提到的lambda代替Runable接口中，我们替换了内部类，但是两者在范围上是不同的。</p><p>当我们使用内部类时，它将创建一个新的作用域，你可以通过实例化具有相同名称的新局部变量来从封闭范围中隐藏局部变量，也可以使用this来作为实例的引用。而lambda中，你无法拥有一个新的作用域。<br>为什么呢？</p><p>这是因为匿名内部类仍然是一个类，通过javac可以看到会将匿名内部类重新编译为一个class文件，只是这个类名不需要人为指定，编译器会自动命名。</p><p>lambda表达式是通过invokedynamic指令实现，不会产生新的类。</p><h3 id="使用方法引用"><a href="#使用方法引用" class="headerlink" title="使用方法引用"></a>使用方法引用</h3><p>方法引用不是方法调用，方法引用是 lambda 表达式的语法糖，任何用方法引用的地方都可由lambda表达式替换，但是不是所有的lambda表达式都可以使用方法引用来替换。（范围有区别）</p><p>静态方法引用  类名::静态方法名<br>实例方法引用  对象名(引用名) :: 实例方法名<br>类方法引用  类名::实例方法名<br>构造方法引用  类名::new</p><p>所以lambda表达式：</p><pre class="line-numbers language-[java]"><code class="language-[java]">a -> a.toLowerCase();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以替换为</p><pre class="line-numbers language-[java]"><code class="language-[java]">//类名::实例方法名String :: toLowerCase<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="外部变量使用final修饰"><a href="#外部变量使用final修饰" class="headerlink" title="外部变量使用final修饰"></a>外部变量使用final修饰</h3><p>在Java中方法的调用是值传递的，lambda也不例外，我们在lambda表达式中对变量的操作都是基于原变量的副本，不会影响到原变量的值的。</p><p>如果我们在lambda表达式外部变量不用final修饰，那么开发者会认为外部变量的值可以在lambda中被改变，而实际是不可能的，所以编译期会要求使用final来修饰外部变量。（如果不显式的声明为final，则不允许出现修改该局部变量的操作，即<strong>隐式的final</strong>）</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lambda </tag>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
