<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高性能的ConcurrentHashMap源码分析</title>
      <link href="/archives/b726e27b.html"/>
      <url>/archives/b726e27b.html</url>
      
        <content type="html"><![CDATA[<h2 id="ConcurrentHashMap简介"><a href="#ConcurrentHashMap简介" class="headerlink" title="ConcurrentHashMap简介"></a>ConcurrentHashMap简介</h2><p>HashMap是线程不安全的，HashTable在方法上使用了synchronized进行方法同步，在多线程时，多个线程竞争同一把锁，导致效率很低，在JDK1.5时,引入了ConcurrentHashMap，利用分段锁（segment），将ConcurrentHashMap分成多段，每一段分配一把锁，当A线程占有锁的时候，B线程可以访问其他段的数据，提高了性能，在JDK1.8中又放弃了分段锁方案，采用了CAS和synchronized来保证线程安全，数据结构和HashMap（1.8）一样，数组+链表+红黑树。</p><p>synchronized对链表或红黑树的首节点进行加锁，提高了性能。</p><h2 id="ConcurrentHashMap源码"><a href="#ConcurrentHashMap源码" class="headerlink" title="ConcurrentHashMap源码"></a>ConcurrentHashMap源码</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>ConcurrentHashMap的构造方法和HashMap差不多，但是多了一个concurrencyLevel</p><pre><code>public ConcurrentHashMap() {}public ConcurrentHashMap(int initialCapacity) {    if (initialCapacity &lt; 0)        throw new IllegalArgumentException();    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?               MAXIMUM_CAPACITY :               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));    this.sizeCtl = cap;}public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) {    this.sizeCtl = DEFAULT_CAPACITY;    putAll(m);}public ConcurrentHashMap(int initialCapacity, float loadFactor) {    this(initialCapacity, loadFactor, 1);}public ConcurrentHashMap(int initialCapacity,                         float loadFactor, int concurrencyLevel) {    if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)        throw new IllegalArgumentException();    if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins        initialCapacity = concurrencyLevel;   // as estimated threads    long size = (long)(1.0 + (long)initialCapacity / loadFactor);    int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?        MAXIMUM_CAPACITY : tableSizeFor((int)size);    this.sizeCtl = cap;}</code></pre><p>在默认静态变量中提到</p><pre><code>/** * The default concurrency level for this table. Unused but * defined for compatibility with previous versions of this class. */private static final int DEFAULT_CONCURRENCY_LEVEL = 16;</code></pre><p>在JDK1.8之前，采用了分段锁的计算，在初始化的时候使用concurrencyLevel来作为segment数组的长度，也就是支持的最大并发数量，默认是16。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><pre><code>/** * The array of bins. Lazily initialized upon first insertion. * Size is always a power of two. Accessed directly by iterators. * hash表，在第一次put数据时才进行初始化，大小是2的幂次方 */transient volatile Node&lt;K,V&gt;[] table;static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final int hash;    final K key;    volatile V val;    volatile Node&lt;K,V&gt; next;}</code></pre><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><pre><code>public V put(K key, V value) {    return putVal(key, value, false);}/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) {    //ConcurrentHashMap 不允许插入null键，而HashMap允许插入一个null键    if (key == null || value == null) throw new NullPointerException();    //计算可以的hash值    int hash = spread(key.hashCode());    int binCount = 0;    //更新数据使用CAS机制，需要不断重试    for (Node&lt;K,V&gt;[] tab = table;;) {        Node&lt;K,V&gt; f; int n, i, fh;        if (tab == null || (n = tab.length) == 0)            //如table为空，初始化table            tab = initTable();        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {            //通过hash定位Node[]数组的索引，没有Node节点就使用CAS添加到链表的头结点            if (casTabAt(tab, i, null,                         new Node&lt;K,V&gt;(hash, key, value, null)))                break;                   // no lock when adding to empty bin        }        else if ((fh = f.hash) == MOVED)            //如果内部在移动元素（扩容）            tab = helpTransfer(tab, f);        else {            V oldVal = null;            //使用synchronized锁住头结点            synchronized (f) {                //判断f是否是链表的头结点                if (tabAt(tab, i) == f) {                    // 确保put没有发生在扩容的过程中，fh=-1时表示正在扩容                    if (fh &gt;= 0) {                        binCount = 1;                        for (Node&lt;K,V&gt; e = f;; ++binCount) {                            K ek;                            if (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != null &amp;&amp; key.equals(ek)))) {                                //如果节点存在，更新value值                                oldVal = e.val;                                if (!onlyIfAbsent)                                    e.val = value;                                break;                            }                            //不存在就添加新节点到链表尾                            Node&lt;K,V&gt; pred = e;                            if ((e = e.next) == null) {                                pred.next = new Node&lt;K,V&gt;(hash, key,                                                          value, null);                                break;                            }                        }                    }                    //如果是TreeBin类型，使用黑红树添加节点方法                    else if (f instanceof TreeBin) {                        Node&lt;K,V&gt; p;                        binCount = 2;                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                       value)) != null) {                            oldVal = p.val;                            if (!onlyIfAbsent)                                p.val = value;                        }                    }                }            }            //如果链表长度大于或等于树化临界值8,进行树化            if (binCount != 0) {                if (binCount &gt;= TREEIFY_THRESHOLD)                    treeifyBin(tab, i);                if (oldVal != null)                    return oldVal;                break;            }        }    }    addCount(1L, binCount);    return null;}</code></pre><p>initTable源码：</p><pre><code>private final Node&lt;K,V&gt;[] initTable() {    Node&lt;K,V&gt;[] tab; int sc;    while ((tab = table) == null || tab.length == 0) {         // sizeCtl的默认值是0，所以最先走到这的线程会进入到下面的else if判断中        if ((sc = sizeCtl) &lt; 0)            //把当前线程变成就绪状态            Thread.yield(); // lost initialization race; just spin        // 尝试原子性的将指定对象(this)的内存偏移量为SIZECT从sc更新为-1        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {            try {                if ((tab = table) == null || tab.length == 0) {                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;                    @SuppressWarnings(&quot;unchecked&quot;)                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];                    // 创建hash表，并赋值给成员变量table                    table = tab = nt;                    sc = n - (n &gt;&gt;&gt; 2);                }            } finally {                sizeCtl = sc;            }            break;        }    }    return tab;}</code></pre><p>这里的变量sizeCtl是表示hash表初始化或扩容时的标志，</p><ul><li>-1 ：正在初始化</li><li>-N ：有N-1个线程正在就行扩容操作</li><li>正数或0 ：还没有被初始化，代表初始化的大小</li></ul><h3 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h3><p>扩容时使用了新的table,</p><pre><code>/** * The next table to use; non-null only while resizing. * 扩容时才使用的hash表，扩容完成后赋值给table，并将nextTable重置为null。 */private transient volatile Node&lt;K,V&gt;[] nextTable;</code></pre><p>扩容方法(addCount())</p><pre><code>private final void addCount(long x, int check) {    CounterCell[] as; long b, s;    if ((as = counterCells) != null ||        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {        CounterCell a; long v; int m;        boolean uncontended = true;        if (as == null || (m = as.length - 1) &lt; 0 ||            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||            !(uncontended =              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {            fullAddCount(x, uncontended);            return;        }        if (check &lt;= 1)            return;        s = sumCount();    }    if (check &gt;= 0) {        Node&lt;K,V&gt;[] tab, nt; int n, sc;        //当键值对的和大于sizeCtl，就进行扩容操作，调用transfer方法        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;               (n = tab.length) &lt; MAXIMUM_CAPACITY) {            int rs = resizeStamp(n);            if (sc &lt; 0) {                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||                    transferIndex &lt;= 0)                    break;                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))                    transfer(tab, nt);            }            else if (U.compareAndSwapInt(this, SIZECTL, sc,                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))                transfer(tab, null);            s = sumCount();        }    }}//transfer/** * Moves and/or copies the nodes in each bin to new table. See * above for explanation. * 移动节点到新table中 */private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {    int n = tab.length, stride;    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)        stride = MIN_TRANSFER_STRIDE; // subdivide range    if (nextTab == null) {            // initiating        try {            @SuppressWarnings(&quot;unchecked&quot;)            // 初始化新的hash表，大小为之前的2倍，并赋值给成员变量nextTable            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];            nextTab = nt;        } catch (Throwable ex) {      // try to cope with OOME            sizeCtl = Integer.MAX_VALUE;            return;        }        nextTable = nextTab;        transferIndex = n;    }    int nextn = nextTab.length;    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);    boolean advance = true;    boolean finishing = false; // to ensure sweep before committing nextTab    for (int i = 0, bound = 0;;) {        Node&lt;K,V&gt; f; int fh;        while (advance) {            int nextIndex, nextBound;            if (--i &gt;= bound || finishing)                advance = false;            else if ((nextIndex = transferIndex) &lt;= 0) {                i = -1;                advance = false;            }            else if (U.compareAndSwapInt                     (this, TRANSFERINDEX, nextIndex,                      nextBound = (nextIndex &gt; stride ?                                   nextIndex - stride : 0))) {                bound = nextBound;                i = nextIndex - 1;                advance = false;            }        }        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {            int sc;            // 扩容完成时，将成员变量nextTable置为null，并将table替换为rehash后的nextTable，更新sizeCtl值            if (finishing) {                nextTable = null;                table = nextTab;                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);                return;            }            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                    return;                finishing = advance = true;                i = n; // recheck before commit            }        }        else if ((f = tabAt(tab, i)) == null)            advance = casTabAt(tab, i, null, fwd);        else if ((fh = f.hash) == MOVED)            advance = true; // already processed        else {            // 接下来是遍历每个链表，对每个链表的元素进行rehash            // 仍然用头结点作为锁，所以在扩容的时候，无法对这个链表执行put操作            synchronized (f) {                if (tabAt(tab, i) == f) {                    Node&lt;K,V&gt; ln, hn;                    if (fh &gt;= 0) {                        int runBit = fh &amp; n;                        Node&lt;K,V&gt; lastRun = f;                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {                            int b = p.hash &amp; n;                            if (b != runBit) {                                runBit = b;                                lastRun = p;                            }                        }                        if (runBit == 0) {                            ln = lastRun;                            hn = null;                        }                        else {                            hn = lastRun;                            ln = null;                        }                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {                            int ph = p.hash; K pk = p.key; V pv = p.val;                            if ((ph &amp; n) == 0)                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);                            else                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);                        }                        // setTabAt方法调用了Unsafe.putObjectVolatile来完成hash表元素的替换                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        setTabAt(tab, i, fwd);                        advance = true;                    }                    else if (f instanceof TreeBin) {                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;                        TreeNode&lt;K,V&gt; lo = null, loTail = null;                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;                        int lc = 0, hc = 0;                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {                            int h = e.hash;                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;                                (h, e.key, e.val, null, null);                            if ((h &amp; n) == 0) {                                if ((p.prev = loTail) == null)                                    lo = p;                                else                                    loTail.next = p;                                loTail = p;                                ++lc;                            }                            else {                                if ((p.prev = hiTail) == null)                                    hi = p;                                else                                    hiTail.next = p;                                hiTail = p;                                ++hc;                            }                        }                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        setTabAt(tab, i, fwd);                        advance = true;                    }                }            }        }    }}</code></pre><p>可以看到很多地方都使用了Unsafe类，在ConcurrentHashMap中，一开始就会执行静态代码块来初始化Unsafe</p><pre><code>// Unsafe mechanicsprivate static final sun.misc.Unsafe U;private static final long SIZECTL;private static final long TRANSFERINDEX;private static final long BASECOUNT;private static final long CELLSBUSY;private static final long CELLVALUE;private static final long ABASE;private static final int ASHIFT;static {    try {        U = sun.misc.Unsafe.getUnsafe();        Class&lt;?&gt; k = ConcurrentHashMap.class;        SIZECTL = U.objectFieldOffset            (k.getDeclaredField(&quot;sizeCtl&quot;));        TRANSFERINDEX = U.objectFieldOffset            (k.getDeclaredField(&quot;transferIndex&quot;));        BASECOUNT = U.objectFieldOffset            (k.getDeclaredField(&quot;baseCount&quot;));        CELLSBUSY = U.objectFieldOffset            (k.getDeclaredField(&quot;cellsBusy&quot;));        Class&lt;?&gt; ck = CounterCell.class;        CELLVALUE = U.objectFieldOffset            (ck.getDeclaredField(&quot;value&quot;));        Class&lt;?&gt; ak = Node[].class;        ABASE = U.arrayBaseOffset(ak);        int scale = U.arrayIndexScale(ak);        if ((scale &amp; (scale - 1)) != 0)            throw new Error(&quot;data type scale not a power of two&quot;);        ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);    } catch (Exception e) {        throw new Error(e);    }}</code></pre><p>objectFieldOffset()用于获取指定Field在内存中的偏移量。<br>Unsafe类是JDK提供的硬件级的原子操作，一般不直接使用。</p><h2 id="可见性（volatile）"><a href="#可见性（volatile）" class="headerlink" title="可见性（volatile）"></a>可见性（volatile）</h2><p>volatile实现可见性，即一个线程的修改对其他线程是可见的，当一个变量使用<strong>volatile</strong>关键字修饰，会注意这个变量是共享的，因此不会将该变量的操作与其他内存操作进行重排序，因为这个变量是共享的，其后面的操作可能还没有开始进行，但是volatile不能保证原子性。</p><p>在扩容的过程中，对table使用了volatile修饰，而每一节点Node元素的hash和key使用final修饰，是不可更改的，而val和下一个节点的引用next也使用volatile修饰保证了可见性。</p><pre><code>transient volatile Node&lt;K,V&gt;[] table;static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final int hash;    final K key;    volatile V val;    volatile Node&lt;K,V&gt; next;}</code></pre><p>key对应元素的可见性，使用了Unsafe的getObjectVolatile()来保证。</p><pre><code>static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {    return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> Map </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码分析</title>
      <link href="/archives/ca4438af.html"/>
      <url>/archives/ca4438af.html</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h2><p>HashMap是出现在JDK1.2中，底层基于散列（Hash）算法实现。HashMap允许null键和null值， null键哈希值为0.HashMap是线程不安全的，在多线程下可能出现问题，在多线程下官方推荐的是ConcurrentHashMap。</p><h3 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h3><p>散列算法，又称哈希算法，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出值就是散列值。实际上很是一种压缩映射，借此来减少所占空间。良好的散列算法应该保证计算hash值简单，不可逆，并且减少hash冲突。</p><p>Hash冲突指通过Hash算法得到的值一样，发生了碰撞。</p><p>在版本控制工具中，可以借助散列算法来标记文件，当文件改变后，哈希值也会改变。Git就采用了SHA1散列（SHA表示安全哈希算法）。不过目前已经出现SHA1碰撞了，可以使用SHA2-256，对SHA2而言，有2的256次方中组合，这个值很大，所以发生碰撞的几率更小，SSL证书已经采用了SHA2标准。</p><h2 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h2><p>HashMap底层采用拉链式的散列算法， 在JDK1.8中，引入了红黑树来处理过长的链表，底层数据结构变成了数组+链表+红黑树。<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://res.cloudinary.com/dikqccyyc/image/upload/v1580986174/HashMap_jppe5z.png" alt="HashMap结构"></p><h2 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashMap的构造方法有四个，主要是初始化变量。主要的变量有初始容量（initialCapacity）、负载因子（loadFactor）、阀值（threshold），其中<strong>threshold = capacity * load factor</strong>。</p><pre><code>//初始容量和负载因子设置public HashMap(int initialCapacity, float loadFactor) {    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                           initialCapacity);    if (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                           loadFactor);    this.loadFactor = loadFactor;    this.threshold = tableSizeFor(initialCapacity);}//初始容量设置public HashMap(int initialCapacity) {    this(initialCapacity, DEFAULT_LOAD_FACTOR);}//无参构造public HashMap() {    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted}public HashMap(Map&lt;? extends K, ? extends V&gt; m) {    this.loadFactor = DEFAULT_LOAD_FACTOR;    putMapEntries(m, false);}    </code></pre><p>最常用的是无参构造，它默认初始容量为16，负载因子为0.75，所以阀值=16*0.75=12，当使用设置容量时，使用了下面方法来计算阀值</p><pre><code>this.threshold = tableSizeFor(initialCapacity);/** * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) {    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}</code></pre><p>这个方法通过多次无符号右移和按位或计算，得到了大于或等于cap的最小2的幂。对于本身就是2的幂次方数，第一步就进行了-1操作，最后一步再进行范围判断。</p><p>在《阿里巴巴Java开发手册》中建议：<br>initialCapacity = （需要存储的元素个数 / 负载因子）+ 1</p><p>比如我们需要保存7个元素,那么JDK按照tableSizeFor方法计算得到8，同时阀值为 8*0.75=6,达到6的时候会自动扩容，扩容是会先扩大到2原来的2倍，同时遍历hash并重新赋值，非常消耗性能，我们按照阿里的规范就可以设置为7/0.75(默认) + 1 = 10,这时JDK计算得到16，这样就会减少扩容的几率，但是这是利用空间换时间的做法，牺牲了部分内存。</p><h3 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h3><p>HashMap的get方法是先定位键值对所在的桶位置，然后再对链表或红黑树进行查找。</p><pre><code>public V get(Object key) {    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;}final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    //1.定位键值对所在的桶位置    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) {        if (first.hash == hash &amp;&amp; //2.总是先查找第一个，第一个是就直接返回            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        if ((e = first.next) != null) {            //3.1 如果第一个是TreeNode类型，调用红黑树查找方法            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            //3.1 如果第一个不是TreeNode类型，调用链表查找方法（while循环）            do {                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            } while ((e = e.next) != null);        }    }    return null;}    </code></pre><h3 id="插入方法"><a href="#插入方法" class="headerlink" title="插入方法"></a>插入方法</h3><p>当对HashMap进行插入操作时，需要考虑扩容，然后还需要考虑链表和红黑树的转化情况。</p><pre><code>public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    //初始化桶数组，当有数据插入时才进行初始化    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    //如果桶中没有键值对，则直接插入到桶中    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        //如果键的值以及节点hash等于链表中第一个键值对节点，则将e指向该键值对        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        //或者桶中是TreeNode类型，则使用红黑树的插入方法        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            //遍历链表            for (int binCount = 0; ; ++binCount) {                //将该节点放在链表末端                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    //如果链表长度大于或等于树型化阀值，转化为红黑树                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                }                //如果已经包含了该键值对，结束操作                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }        //如果要插入的键值对存在HashMap中        if (e != null) { // existing mapping for key            V oldValue = e.value;            //如果oldValue为null更新值            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    //如果键值对数量超过阀值，进行扩容，resize()操作    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;} </code></pre><h3 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h3><p>上面提到了插入操作后如果键值对数量超过阀值，进行扩容，resize()操作，因为初始化的时候定义了数组的长度为2的幂次方，扩容的时还是变成原来的2倍，继续保存2的幂次方。</p><pre><code>final Node&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    if (oldCap &gt; 0) {        if (oldCap &gt;= MAXIMUM_CAPACITY) {            threshold = Integer.MAX_VALUE;            return oldTab;        }        //右移一位，变成原来的2倍        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1; // double threshold    }    else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else {               // zero initial threshold signifies using defaults        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    }    if (newThr == 0) {        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    }    threshold = newThr;    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})    //创建新的桶的数组        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    //如果旧数组不为空，遍历旧数组，并将键值对都放到新数组中    if (oldTab != null) {        for (int j = 0; j &lt; oldCap; ++j) {            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) {                oldTab[j] = null;                if (e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                else if (e instanceof TreeNode)                    //拆分红黑树                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else { // preserve order                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    //遍历链表，按照原顺序进行分组                    do {                        next = e.next;                        if ((e.hash &amp; oldCap) == 0) {                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        }                        else {                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        }                    } while ((e = next) != null);                    //将分组后的链表映射到新桶中                    if (loTail != null) {                        loTail.next = null;                        newTab[j] = loHead;                    }                    if (hiTail != null) {                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    }                }            }        }    }    return newTab;}</code></pre><p>在扩容的过程中，需要注意对键值对进行重新映射，将对键值对进行分组，然后将分组后链表放到数组桶中，在在重新映射时保持了相同的节点顺序。</p><p>同时，如果<strong>扩容时链表的长度&gt;= TREEIFY_THRESHOLD以及桶数组容量&gt;=MIN_TREEIFY_CAPACITY</strong>，会进行树化。如果桶数组很小，键值对发生hash碰撞的几率更高，就会导致链表过长，此时，会优先考虑扩容，增加桶数组的容量。</p><pre><code>/** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. * 如果表太小，将进行扩容，否则将节点进行树化。 */final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {    int n, index; Node&lt;K,V&gt; e;    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {        TreeNode&lt;K,V&gt; hd = null, tl = null;        do {            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);            if (tl == null)                hd = p;            else {                p.prev = tl;                tl.next = p;            }            tl = p;        } while ((e = e.next) != null);        if ((tab[index] = hd) != null)            hd.treeify(tab);    }} </code></pre><p>树化时TreeNode继承了LinkedHashMap.Entry,TreeNode仍然保留了next和prev引用，这样可以按照遍历链表的方法来遍历红黑树。也方便将红黑树重新转化为链表操作。</p><pre><code>TreeNode&lt;K,V&gt; parent;  // red-black tree linksTreeNode&lt;K,V&gt; left;TreeNode&lt;K,V&gt; right;TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletionboolean red;TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {super(hash, key, val, next);}</code></pre><h3 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h3><p>HashMap的删除也是先定位桶位置，在遍历链表，在删除节点，删除后需要重新修复链表和红黑树，可能涉及到红黑树重新转化为链表的过程。</p><pre><code>public V remove(Object key) {    Node&lt;K,V&gt; e;    return (e = removeNode(hash(key), key, null, false, true)) == null ?        null : e.value;}final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,                           boolean matchValue, boolean movable) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;    //先是查找操作，跟上面一样    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (p = tab[index = (n - 1) &amp; hash]) != null) {        Node&lt;K,V&gt; node = null, e; K k; V v;        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            node = p;        else if ((e = p.next) != null) {            if (p instanceof TreeNode)                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);            else {                do {                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key ||                         (key != null &amp;&amp; key.equals(k)))) {                        node = e;                        break;                    }                    p = e;                } while ((e = e.next) != null);            }        }        //删除节点        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||                             (value != null &amp;&amp; value.equals(v)))) {            //如果是TreeNode类型，调用红黑树的删除方法            if (node instanceof TreeNode)                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);            else if (node == p)                tab[index] = node.next;            else                p.next = node.next;            ++modCount;            --size;            afterNodeRemoval(node);            return node;        }    }    return null;}</code></pre><h2 id="HashMap注意项"><a href="#HashMap注意项" class="headerlink" title="HashMap注意项"></a>HashMap注意项</h2><h3 id="JDK1-8前高并发时可能出现死链"><a href="#JDK1-8前高并发时可能出现死链" class="headerlink" title="JDK1.8前高并发时可能出现死链"></a>JDK1.8前高并发时可能出现死链</h3><p>JDK1.8前，resize包含扩容和rehash操作，如果HashMap处于扩容临界点，当多个线程同时插入键值对时，可能会形成死链。</p><h3 id="transient修饰的table"><a href="#transient修饰的table" class="headerlink" title="transient修饰的table"></a>transient修饰的table</h3><pre><code>transient Node&lt;K,V&gt;[] table;</code></pre><p>HashMap实现了Serializable接口，需要进行序列化和反序列化，但是这里使用transient来修饰存放键值对的table，我们知道transient修饰的变量是不进行序列化的，这明明就是矛盾的，为什么这么设计呢？<br>实际上，HashMap是基于HashCode，而HashCode是Object的方法,该方法被native修饰，那不同JVM有不用的HashCode算法，我们不能在不同的平台上进行序列化和反序列化操作，所以HashMap重写了writeObject和readObject方法。同时，table中元素有很多空位置，如果都序列化，浪费空间。</p><pre><code>//Object的hashCode()public native int hashCode();</code></pre><p>重写了序列化和反序列化方法：</p><pre><code>private void writeObject(java.io.ObjectOutputStream s)    throws IOException {    int buckets = capacity();    // Write out the threshold, loadfactor, and any hidden stuff    s.defaultWriteObject();    s.writeInt(buckets);    s.writeInt(size);    internalWriteEntries(s);}private void readObject(java.io.ObjectInputStream s)    throws IOException, ClassNotFoundException {    // Read in the threshold (ignored), loadfactor, and any hidden stuff    s.defaultReadObject();    reinitialize();    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +                                         loadFactor);    s.readInt();                // Read and ignore number of buckets    int mappings = s.readInt(); // Read number of mappings (size)    if (mappings &lt; 0)        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +                                         mappings);    else if (mappings &gt; 0) { // (if zero, use defaults)        // Size the table using given load factor only if within        // range of 0.25...4.0        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);        float fc = (float)mappings / lf + 1.0f;        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?                   DEFAULT_INITIAL_CAPACITY :                   (fc &gt;= MAXIMUM_CAPACITY) ?                   MAXIMUM_CAPACITY :                   tableSizeFor((int)fc));        float ft = (float)cap * lf;        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?                     (int)ft : Integer.MAX_VALUE);        // Check Map.Entry[].class since it&#39;s the nearest public type to        // what we&#39;re actually creating.        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];        table = tab;        // Read the keys and values, and put the mappings in the HashMap        for (int i = 0; i &lt; mappings; i++) {            @SuppressWarnings(&quot;unchecked&quot;)                K key = (K) s.readObject();            @SuppressWarnings(&quot;unchecked&quot;)                V value = (V) s.readObject();            putVal(hash(key), key, value, false, false);        }    }}</code></pre><h3 id="Fast-Fail"><a href="#Fast-Fail" class="headerlink" title="Fast-Fail"></a>Fast-Fail</h3><p>快速失败机制是Java集合中的一种常见错误机制，在使用迭代器iterator的过程中，HashMap的结构发生了更改（比如扩容、插入或删除元素导致size发生了变化），那么在返回的迭代器iterator中进行遍历会抛出 <strong>ConcurrentModificationException</strong>异常，这就是快速失败机制。</p><p>这里利用了<strong>modCount</strong>来帮助实现Fast-Fail，</p><pre><code>/** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash).  This field is used to make iterators on Collection-views of * the HashMap fail-fast.  (See ConcurrentModificationException). *  */transient int modCount;</code></pre><p>在HashMap的HashIterator中，也有个expectedModCount变量</p><pre><code>abstract class HashIterator {    Node&lt;K,V&gt; next;        // next entry to return    Node&lt;K,V&gt; current;     // current entry    int expectedModCount;  // for fast-fail    int index;             // current slot    HashIterator() {        expectedModCount = modCount;        Node&lt;K,V&gt;[] t = table;        current = next = null;        index = 0;        if (t != null &amp;&amp; size &gt; 0) { // advance to first entry            do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);        }    }    public final boolean hasNext() {        return next != null;    }    final Node&lt;K,V&gt; nextNode() {        Node&lt;K,V&gt;[] t;        Node&lt;K,V&gt; e = next;        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        if (e == null)            throw new NoSuchElementException();        if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) {            do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);        }        return e;    }    public final void remove() {        Node&lt;K,V&gt; p = current;        if (p == null)            throw new IllegalStateException();        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        current = null;        K key = p.key;        removeNode(hash(key), key, null, false, false);        expectedModCount = modCount;    }}</code></pre><p>HashIterator的构造器中设置了expectedModCount = modCount，然后在nextNode和remove方法中都进行了判断。</p><pre><code>if (modCount != expectedModCount)    throw new ConcurrentModificationException();</code></pre><p>所以在单线程时要注意不要在Iterator遍历时进行HashMap结构修改操作，在多线程时，可以使用<strong>Collections.synchronizedMap</strong>来构造线程安全的Map，也可以使用线程安全的ConcurrentHashMap。</p>]]></content>
      
      
      <categories>
          
          <category> java8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> 集合 </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal介绍</title>
      <link href="/archives/f3be0909.html"/>
      <url>/archives/f3be0909.html</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h2><p>ThreadLocal支持泛型，如ThreadLocal<String>,ThreadLocal是线程局部变量，它和普通变量相比，每个线程持有这个变量的副本，而且这个副本只能由当前thread使用，这就不存在多线程间之前共享的情况，那么就不存在同步的问题。ThreadLocal变量通常被<strong>private static</strong>修饰，当一个线程结束时，它所使用的所有ThreadLocal相对的实例副本都可被回收。</p><pre class="line-numbers language-[java]"><code class="language-[java]">/** * This class provides thread-local variables.  These variables differ from * their normal counterparts in that each thread that accesses one (via its * {@code get} or {@code set} method) has its own, independently initialized * copy of the variable.  {@code ThreadLocal} instances are typically private * static fields in classes that wish to associate state with a thread (e.g., * a user ID or Transaction ID). */public class ThreadLocal<T> {    ...    //防止hash冲突    private static final int HASH_INCREMENT = 0x61c88647;    protected T initialValue() {        return null;    }    public ThreadLocal() {    }    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到ThreadLocal适用于每个线程需要自己独立的实例并且该实例需要在多个方法中使用的场景。</p><h2 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h2><p>我们需要在每个线程中维护自己独立的实例，那么可以使用Map类型来维护，使用每个线程作为key，对应的实例作为值，但是这个map不能被多个线程共享，否则它就是不安全的，所以它肯定是跟线程绑定在一起的。事实上，在Thread类中：</p><pre class="line-numbers language-[java]"><code class="language-[java]"> /* ThreadLocal values pertaining to this thread. This map is maintained     * by the ThreadLocal class. */    ThreadLocal.ThreadLocalMap threadLocals = null;    /*     * InheritableThreadLocal values pertaining to this thread. This map is     * maintained by the InheritableThreadLocal class.     */    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ThreadLocal.ThreadLocalMap的存在就是ThreadLocal的关键。<br>ThreadLocalMap是一个静态内部类，该类的Entry继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</p><pre class="line-numbers language-[java]"><code class="language-[java]"> static class Entry extends WeakReference<ThreadLocal<?>> {            /** The value associated with this ThreadLocal. */            Object value;            Entry(ThreadLocal<?> k, Object v) {                super(k);                value = v;            }        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里对键使用了弱引用，当没有强引用指向ThreadLocal变量时，它可以被GC回收，从而避免了ThreadLocal没有被回收而出现的内存泄漏的情况<br>同时需要注意的是，ThreadLocalMap中键可以被回收，但是entry却无法被移出，从而使得实例被entry引用而无法回收造成内存泄漏，解决这个问题的方法就是<strong>调用threadLocal的remove</strong>方法，把当前的threadLocal从当前线程的threadLocalMap中移出（key和value）</p><h3 id="读取实例（Get）"><a href="#读取实例（Get）" class="headerlink" title="读取实例（Get）"></a>读取实例（Get）</h3><p>get方法是用来获取threadLocal在当前线程中保存的变量副本</p><pre class="line-numbers language-[java]"><code class="language-[java]"> public T get() {        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null) {            ThreadLocalMap.Entry e = map.getEntry(this);            if (e != null) {                @SuppressWarnings("unchecked")                T result = (T)e.value;                return result;            }        }        return setInitialValue();    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，首先获取到当前线程，并通过getMap(t)方法获取到一个map</p><pre class="line-numbers language-[java]"><code class="language-[java]"> ThreadLocalMap getMap(Thread t) {        return t.threadLocals;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后通过getEntry（this）获取到&lt;key,Value&gt;键值对，this就是当前访问的ThreadLocal对象，如果获取到的entry不为null，就直接获取该entry的值，否则通过setInitialValue()方法设置初始值。</p><h3 id="设置实例（Set）"><a href="#设置实例（Set）" class="headerlink" title="设置实例（Set）"></a>设置实例（Set）</h3><p>set方法是将实例值放到threadLocalMap中</p><pre class="line-numbers language-[java]"><code class="language-[java]">public void set(T value) {        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null)            map.set(this, value);        else            createMap(t, value);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样先获取到当前线程，再获取到当前线程的ThreadLocalMap，最后通过set(this, value)添加到map中，在set(this, value)方法,调用了replaceStaleEntry（）方法将key==null的entry都设置为null，从而防止了内存泄漏。</p><h3 id="删除实例（Remove）"><a href="#删除实例（Remove）" class="headerlink" title="删除实例（Remove）"></a>删除实例（Remove）</h3><pre class="line-numbers language-[java]"><code class="language-[java]">private void remove(ThreadLocal<?> key) {            Entry[] tab = table;            int len = tab.length;            int i = key.threadLocalHashCode & (len-1);            for (Entry e = tab[i];                 e != null;                 e = tab[i = nextIndex(i, len)]) {                if (e.get() == key) {                    e.clear();                    expungeStaleEntry(i);                    return;                }            }        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在remove方法中，调用了expungeStaleEntry方法将key==null的enrty都设置为null，从而防止了内存泄漏。</p><h2 id="ThreadLocal使用场景"><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a>ThreadLocal使用场景</h2><h3 id="Session管理"><a href="#Session管理" class="headerlink" title="Session管理"></a>Session管理</h3><p>在Java Web中，Session保存了很多重要信息，我们经常通过session去获取和保存信息，有时候还需要修改sesson的信息，而且我们需要不同的线程有自己的session实例，之间互不影响，这里可以使用ThreadLocal。</p><pre class="line-numbers language-[java]"><code class="language-[java]">    private static final ThreadLocal threadSession = new ThreadLocal();    public static Session getSession() throws InfrastructureException {        Session s = (Session) threadSession.get();        try {            if (s == null) {                s = getSessionFactory().openSession();                threadSession.set(s);            }        } catch (HibernateException ex) {            throw new InfrastructureException(ex);        }        return s;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dubbo中cache"><a href="#dubbo中cache" class="headerlink" title="dubbo中cache"></a>dubbo中cache</h3><p>在dubbo的CacheFilter中,进行了请求缓存的操作：</p><pre class="line-numbers language-[java]"><code class="language-[java]">@Activate(    group = {"consumer", "provider"},    value = {"cache"})public class CacheFilter implements Filter {    private CacheFactory cacheFactory;    public CacheFilter() {    }    public void setCacheFactory(CacheFactory cacheFactory) {        this.cacheFactory = cacheFactory;    }    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {        if(this.cacheFactory != null && ConfigUtils.isNotEmpty(invoker.getUrl().getMethodParameter(invocation.getMethodName(), "cache"))) {            Cache cache = this.cacheFactory.getCache(invoker.getUrl(), invocation);            if(cache != null) {                String key = StringUtils.toArgumentString(invocation.getArguments());                Object value = cache.get(key);                if(value != null) {                    return new RpcResult(value);                }                Result result = invoker.invoke(invocation);                if(!result.hasException() && result.getValue() != null) {                    cache.put(key, result.getValue());                }                return result;            }        }        return invoker.invoke(invocation);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在RPC调用invoke方法前，会先使用请求参数判断当前线程是否刚刚发起过相同参数的调用，这个调用是在缓存中保存了的，dubbo提供了三种缓存实现</p><pre><code>threadlocal=com.alibaba.dubbo.cache.support.threadlocal.ThreadLocalCacheFactorylru=com.alibaba.dubbo.cache.support.lru.LruCacheFactoryjcache=com.alibaba.dubbo.cache.support.jcache.JCacheFactory</code></pre><p>在其中的ThreadLocalCacheFactory工厂中提供了ThreadLocalCache(Url url)构造方法，提供了ThreadLocalCache</p><pre class="line-numbers language-[java]"><code class="language-[java]">public class ThreadLocalCache implements Cache {    private final ThreadLocal<Map<Object, Object>> store = new ThreadLocal<Map<Object, Object>>() {        protected Map<Object, Object> initialValue() {            return new HashMap();        }    };    public ThreadLocalCache(URL url) {    }    public void put(Object key, Object value) {        ((Map)this.store.get()).put(key, value);    }    public Object get(Object key) {        return ((Map)this.store.get()).get(key);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ThreadLocal和线程池"><a href="#ThreadLocal和线程池" class="headerlink" title="ThreadLocal和线程池"></a>ThreadLocal和线程池</h2><p>ThreadLocal对象的生命周期和线程的生命周期一样长，线程池中的线程是复用的，所以线程的ThreadLocal会互相串来串去，所以不建议在和线程池一起使用，如果必须一起使用，建议在线程使用完成后清除到线程中绑定的threadLocal。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存泄漏 </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈Java内存泄漏</title>
      <link href="/archives/39e22680.html"/>
      <url>/archives/39e22680.html</url>
      
        <content type="html"><![CDATA[<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>在计算机科学中，<strong>内存泄漏</strong>指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该内存之前就失去了对该段内存的控制，从而造成了内存的浪费。（维基百科）</p><p>在Java中，设计了垃圾回收器进行自动回收垃圾，而不在需要我们手动进行内存释放，给我们编程带来了便捷，但同时也使得内存泄漏更加隐蔽。</p><h3 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h3><p>在编程过程中，我们在内存中申请一块区域进行创建对象，在使用完成之后，我们希望这块内存可以立即被回收掉，这是我们的理想情况，但是GC线程的优先级别很低，同时JVM调用GC的策略也有所不同，就存在引用在内存中包含对象的时间长于预期的存活时间的情况，这样就可能出现内存泄漏。</p><p>我们经常看到静态集合类内存泄漏的一个例子：</p><pre class="line-numbers language-[java]"><code class="language-[java]">Static Vector v = new Vector();for (int i=1;i<100;i++){    Object o = new Object();    v.add(o);    o = null;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用了for循环创建对象并把对象加入到Vector中，这里并没有什么问题，但是如果继续对Vector进行操作，而在方法结束时却没有对<strong>vector</strong>进行赋值null操作，就会出现GC无法回收这100个object对象的问题。所以需要加上</p><pre><code>v = null;</code></pre><p>下面是通过减少对象作用域来避免Java内存泄漏的典型情况(LinkedList源码)：</p><pre class="line-numbers language-[java]"><code class="language-[java]">     /**     * Unlinks non-null node x.     * 删除指定节点并返回被删除的元素值     */    E unlink(Node<E> x) {        // assert x != null;        final E element = x.item;        final Node<E> next = x.next;        final Node<E> prev = x.prev;        if (prev == null) {            //如果前一个节点为空（当前节点就是首节点），将后一个节点设置为新的首节点            first = next;        } else {            //如果前一个节点不为空，那么它的后一个节点设置为前节点的后节点            prev.next = next;            //方便GC回收            x.prev = null;        }        if (next == null) {            //如果后一个节点为空（当前节点是尾节点），将前一个节点设置为新的尾节点            last = prev;        } else {            //如果后一个节点不为空，将后节点的前节点设置为删除元素的前节点            next.prev = prev;            //方便GC回收            x.next = null;        }        x.item = null;        size--;        modCount++;        return element;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码是LinkedList删除指定节点的内部方法，我们不仅改变了前后节点的前后指向关系，还进行了赋值null的操作，方便GC回收。</p><h3 id="常见的内存泄漏情况"><a href="#常见的内存泄漏情况" class="headerlink" title="常见的内存泄漏情况"></a>常见的内存泄漏情况</h3><h4 id="静态集合类"><a href="#静态集合类" class="headerlink" title="静态集合类"></a>静态集合类</h4><p>比如HashMap，Vector等集合，这些静态变量的生命周期和程序一致，他们引用的对象不能被回收</p><h4 id="各种资源连接"><a href="#各种资源连接" class="headerlink" title="各种资源连接"></a>各种资源连接</h4><p>我们经常使用的数据库连接、网络连接、IO连接，以及使用框架的资源连接（Hibernate的SessionFacotry获取的session对象）</p><pre><code>Session session = sessionFactory.openSession();</code></pre><p>使用完成后需要进行关闭</p><pre><code>try{    session=sessionFactory.openSession();    //数据库操作}finally{    session.close();}</code></pre><h4 id="单例模式导致的内存泄漏"><a href="#单例模式导致的内存泄漏" class="headerlink" title="单例模式导致的内存泄漏"></a>单例模式导致的内存泄漏</h4><p>单例模式是一个长生命周期的对象，如果这个对象持有其他对象的引用，就很容易发生内存泄漏。</p><h4 id="内部类和外部模块的引用"><a href="#内部类和外部模块的引用" class="headerlink" title="内部类和外部模块的引用"></a>内部类和外部模块的引用</h4><p>内部类的对象隐式持有了外部模块对象，影响了外部类对象的回收，解决方法是将内部类定义为静态内部类，静态内部类不会隐式持有外部对象的引用。<br>静态内部类中引用外部类的变量必须是静态对象，存放在JVM内存模型中的方法区，从而可以直接的引用到需要的变量<br>非静态内部类中引用外部类的变量是通过隐式持有外部类对象，可以通过编译后的字节码可以看出来。</p><h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><p>通常会使用各种监听器来监听对象的相关事件，但是释放对象的时候却没有删除这些监听器</p><h3 id="如何避免发生内存泄漏"><a href="#如何避免发生内存泄漏" class="headerlink" title="如何避免发生内存泄漏"></a>如何避免发生内存泄漏</h3><h4 id="良好的编码习惯"><a href="#良好的编码习惯" class="headerlink" title="良好的编码习惯"></a>良好的编码习惯</h4><p>最简单的方法就是<strong>尽早的释放无关对象</strong>，这样让GC可以尽早回收，<br>同时我们需要注意该对象是否被监听，若是，则首先去掉监听器；当对象是一个Thread时，删除之前先调用<strong>interrupt()</strong>方法来通知线程应该中断了；代码中同时注意异常处理，是否存在相关的连接是否需要关闭等。</p><h4 id="使用测试工具"><a href="#使用测试工具" class="headerlink" title="使用测试工具"></a>使用测试工具</h4><p>可以使用检测工具来查看，比如jstack,jconsole,jmap,jstat等等</p><h4 id="使用弱引用"><a href="#使用弱引用" class="headerlink" title="使用弱引用"></a>使用弱引用</h4><p>弱引用是对一个对象的引用的持有者，在GC时，无论内存是否足够，对象均会被回收。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 内存泄漏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈Java弱引用</title>
      <link href="/archives/eee3a181.html"/>
      <url>/archives/eee3a181.html</url>
      
        <content type="html"><![CDATA[<h2 id="引用概述"><a href="#引用概述" class="headerlink" title="引用概述"></a>引用概述</h2><p>在Java中，存在着四种引用类型，它们按照由强到弱依次是：强引用、软引用、弱引用、虚引用，我们可以用不用的引用来更加了灵活的控制对象的生命周期。</p><h3 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h3><p>类型共有四种，分别是：</p><ul><li>强引用（StrongReference）：最常见的引用，如果一个对象拥有强引用，那GC不会对它进行回收，虚拟机宁愿抛出OutOfMemoryError错误，也不会来回收具有强引用的对象来达到解决内存不足的目地。<br><code>（Object obj = new Object()）</code></li><li>软引用（SoftReference）：如果一个对象拥有软引用，并且内存足够，GC就不会回收它，而在内存不足时，就是回收这个对象的内存。只要GC没有回收它，该对象就可以被程序使用，可以通过软引用来实现缓存的功能<br><code>（SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(new Object())//sf就是软引用，可以通过sf.get()获取该对象，若对象被回收了，则获取到的是null）</code></li><li>弱引用（WeakReference）： 在GC时，无论内存是否足够，均会被回收，不过垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只有弱引用的对象<br><code>（WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(new Object())//wf就是弱引用，GC回收后获取到null）</code></li><li>虚引用（PhantomReference）：虚在这里的意思就是“<strong>形同虚设</strong>”，虚引用不会觉得对象的生命周期，如果一个对象仅持有虚引用，那么就和没有引用一样。虚引用主要用来跟踪垃圾回收器的活动，因为虚引用一般跟引用队列一起使用，回收对象前，将这个虚引用加入这个歌引用队列中，从而记录它指向的对象已经被回收。</li></ul><h2 id="弱引用介绍"><a href="#弱引用介绍" class="headerlink" title="弱引用介绍"></a>弱引用介绍</h2><p>WeakReference类位于java.lang.ref下：</p><pre class="line-numbers language-[java]"><code class="language-[java]">public class WeakReference<T> extends Reference<T> {    /**     * Creates a new weak reference that refers to the given object.  The new     * reference is not registered with any queue.     *     * @param referent object the new weak reference will refer to     */    public WeakReference(T referent) {        super(referent);    }    /**     * Creates a new weak reference that refers to the given object and is     * registered with the given queue.     *     * @param referent object the new weak reference will refer to     * @param q the queue with which the reference is to be registered,     *          or <tt>null</tt> if registration is not required     */    public WeakReference(T referent, ReferenceQueue<? super T> q) {        super(referent, q);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个构造方法的区别是第二个构造方法中加入了ReferenceQueue的引用队列，当这个引用被回收后，就会将其加入到这个引用队列中。</p><h3 id="WeakReference-T-referent"><a href="#WeakReference-T-referent" class="headerlink" title="WeakReference(T referent)"></a>WeakReference(T referent)</h3><p>基础类User</p><pre class="line-numbers language-[java]"><code class="language-[java]">@Data@AllArgsConstructorpublic class User{    private String name;    private int age;    @Override    protected void finalize() throws Throwable    {        System.out.println("开始GC");        super.finalize();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继承WeakReference<User>的UserRef：</p><pre class="line-numbers language-[java]"><code class="language-[java]">public class UserRef extends WeakReference<User>{    public UserRef(User referent)    {        super(referent);    }    public UserRef(User referent, ReferenceQueue<? super User> q)    {        super(referent, q);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>WeakReferenceDemo的dome1：</p><pre class="line-numbers language-[java]"><code class="language-[java]">public class WeakReferenceDemo{    public static void main(String[] args)    {        dome1();        //dome2();        //dome3();    }    private static void dome1()    {        //user是强引用，GC不回收        User user = new User("huang", 20);        UserRef userRef = new UserRef(user);        UserRef userRef2 = new UserRef(new User("zhangsan", 18));        UserRef userRef3 = new UserRef(new User("lisi", 25));        System.out.println(userRef.get());        System.out.println(userRef2.get());        System.out.println(userRef3.get());        System.out.println("-----请求GC-----");        System.gc();        try        {            Thread.sleep(1000);        } catch (InterruptedException e)        {            e.printStackTrace();        }        //回收的是User        System.out.println(userRef);        System.out.println(userRef2);        System.out.println(userRef3);        System.out.println(userRef.get());        System.out.println(userRef2.get());        System.out.println(userRef3.get());    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre><code>User(name=huang, age=20)User(name=zhangsan, age=18)User(name=lisi, age=25)-----请求GC-----开始GC开始GCcom.hq.test.UserRef@5aaa6d82Disconnected from the target VM, address: &#39;127.0.0.1:56573&#39;, transport: &#39;socket&#39;com.hq.test.UserRef@73a28541com.hq.test.UserRef@6f75e721User(name=huang, age=20)nullnull</code></pre><p>可以看到GC只回收弱引用</p><h3 id="WeakReference-T-referent-ReferenceQueue-lt-super-T-gt-q"><a href="#WeakReference-T-referent-ReferenceQueue-lt-super-T-gt-q" class="headerlink" title="WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q)"></a>WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q)</h3><p>dome2</p><pre class="line-numbers language-[java]"><code class="language-[java]"> private static void dome2()    {        ReferenceQueue queue = new ReferenceQueue();        UserRef userRef2 = new UserRef(new User("zhangsan", 18), queue);        UserRef userRef3 = new UserRef(new User("lisi", 25), queue);        System.out.println(userRef2.get());        System.out.println(userRef3.get());        Reference<? extends User> reference = null;        while ((reference = queue.poll())!=null){            //还没有GC,队列中没有值不会有输出            System.out.println("队列中的值:" + reference);        }        System.out.println("-----请求GC-----");        System.gc();        try        {            Thread.sleep(1000);        } catch (InterruptedException e)        {            e.printStackTrace();        }        System.out.println(userRef2);        System.out.println(userRef3);        System.out.println(userRef2.get());        System.out.println(userRef3.get());        while ((reference = queue.poll())!=null){            System.out.println("队列中的值:" + reference);        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在main方法中运行方法dome2</p><p>输出：</p><pre><code>User(name=zhangsan, age=18)User(name=lisi, age=25)-----请求GC-----开始GC开始GCDisconnected from the target VM, address: &#39;127.0.0.1:56582&#39;, transport: &#39;socket&#39;com.hq.test.UserRef@5aaa6d82com.hq.test.UserRef@73a28541nullnull队列中的值:com.hq.test.UserRef@5aaa6d82队列中的值:com.hq.test.UserRef@73a28541</code></pre><p>可以看到被回收的弱引用对象加到了队列中</p><pre class="line-numbers language-[java]"><code class="language-[java]">  private static void dome3()    {        ReferenceQueue queue = new ReferenceQueue();        UserRef userRef2 = new UserRef(new User("zhangsan", 18), queue);        UserRef userRef3 = new UserRef(new User("lisi", 25), queue);        System.out.println(userRef2.get());        //clear方法手动清除        userRef2.clear();        //已经被clear方法清除了,get到null值        System.out.println(userRef2.get());        System.out.println(userRef3.get());        Reference<? extends User> reference = null;        while ((reference = queue.poll())!=null){            //还没有GC,队列中没有值不会有输出            System.out.println("队列中的值:" + reference);        }        System.out.println("-----请求GC-----");        System.gc();        try        {            Thread.sleep(1000);        } catch (InterruptedException e)        {            e.printStackTrace();        }        System.out.println(userRef2);        System.out.println(userRef3);        System.out.println(userRef2.get());        System.out.println(userRef3.get());        while ((reference = queue.poll())!=null){            System.out.println("队列中的值:" + reference);        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在main方法中运行方法dome3</p><p>输出：</p><pre><code>User(name=zhangsan, age=18)nullUser(name=lisi, age=25)-----请求GC-----开始GC开始GCDisconnected from the target VM, address: &#39;127.0.0.1:56594&#39;, transport: &#39;socket&#39;com.hq.test.UserRef@5aaa6d82com.hq.test.UserRef@73a28541nullnull队列中的值:com.hq.test.UserRef@73a28541</code></pre><p>这里可以看出队列中只有一个值了</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda简介</title>
      <link href="/archives/14747.html"/>
      <url>/archives/14747.html</url>
      
        <content type="html"><![CDATA[<h2 id="lambda概述"><a href="#lambda概述" class="headerlink" title="lambda概述"></a>lambda概述</h2><p>同其他编程语言相比，在Java8之前，Java缺少了高效的并行操作，使得编写并发程序的代码非常臃肿，所以在Java8中，借鉴了函数式编程的思想引入了lambda表达式，lambda是一种匿名函数。通俗点讲，它没有声明的方法，也就没有访问的修饰符、返回值声明和名字，让代码更加紧凑高效和易于阅读。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>(parameters)-&gt;{statements} </p><p>or</p><p>(parameters)-&gt;statements</p><p>or</p><p> (parameters)-&gt;expression</p><p>eg：</p><pre class="line-numbers language-[java]"><code class="language-[java]">//无参函数() -> 8；//两个参数函数，返回它们的和,一行代码的话可以去掉花括号{}(a，b) -> a+b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lambda使用"><a href="#lambda使用" class="headerlink" title="lambda使用"></a>lambda使用</h2><p>我们可以使用lambda表达式来替换匿名类，这里使用Runable来举例：</p><pre class="line-numbers language-[java]"><code class="language-[java]">//java8之前new Thread(new Runnable()        {            @Override            public void run()            {                System.out.println("hello world");            }        }).start();//java8new Thread(()-> System.out.println("hello world")).start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以明显的看到代码精简了很多，而且更加方便阅读，在这里我们看不到run方法了，这是因为在Runable接口下只有一个方法的原因，如果有多个，匿名函数是没有办法来区分的。</p><pre class="line-numbers language-[java]"><code class="language-[java]">@FunctionalInterfacepublic interface Runnable {    public abstract void run();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用<strong>@FunctionalInterface</strong>来声明该接口是函数式接口，就是说在这个接口中<strong>只能有一个抽象方法</strong>，如果我们在接口中定义了两个抽象方法，开发工具会对编译级错误检查进行报错的。我们可以利用@FunctionalInterface注解在多个接口的大型项目中控制接口，让其无法添加其他的抽象方法。<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://res.cloudinary.com/dikqccyyc/image/upload/v1577881736/functionalInterface_af5vfo.png" alt="编译级错误"></p><p>JDK中函数式接口例子：</p><ul><li>java.lang.Runable</li><li>java.util.concurrent.Callable</li><li>java.util.Comparator</li><li>java.util.function包下的接口,如Function，Consumer，Predicate，Supplier</li></ul><h3 id="不要将lambda表达式视为内部类"><a href="#不要将lambda表达式视为内部类" class="headerlink" title="不要将lambda表达式视为内部类"></a>不要将lambda表达式视为内部类</h3><p>在前面提到的lambda代替Runable接口中，我们替换了内部类，但是两者在范围上是不同的。</p><p>当我们使用内部类时，它将创建一个新的作用域，你可以通过实例化具有相同名称的新局部变量来从封闭范围中隐藏局部变量，也可以使用this来作为实例的引用。而lambda中，你无法拥有一个新的作用域。<br>为什么呢？</p><p>这是因为匿名内部类仍然是一个类，通过javac可以看到会将匿名内部类重新编译为一个class文件，只是这个类名不需要人为指定，编译器会自动命名。</p><p>lambda表达式是通过invokedynamic指令实现，不会产生新的类。</p><h3 id="使用方法引用"><a href="#使用方法引用" class="headerlink" title="使用方法引用"></a>使用方法引用</h3><p>方法引用不是方法调用，方法引用是 lambda 表达式的语法糖，任何用方法引用的地方都可由lambda表达式替换，但是不是所有的lambda表达式都可以使用方法引用来替换。（范围有区别）</p><p>静态方法引用  类名::静态方法名<br>实例方法引用  对象名(引用名) :: 实例方法名<br>类方法引用  类名::实例方法名<br>构造方法引用  类名::new</p><p>所以lambda表达式：</p><pre class="line-numbers language-[java]"><code class="language-[java]">a -> a.toLowerCase();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以替换为</p><pre class="line-numbers language-[java]"><code class="language-[java]">//类名::实例方法名String :: toLowerCase<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="外部变量使用final修饰"><a href="#外部变量使用final修饰" class="headerlink" title="外部变量使用final修饰"></a>外部变量使用final修饰</h3><p>在Java中方法的调用是值传递的，lambda也不例外，我们在lambda表达式中对变量的操作都是基于原变量的副本，不会影响到原变量的值的。</p><p>如果我们在lambda表达式外部变量不用final修饰，那么开发者会认为外部变量的值可以在lambda中被改变，而实际是不可能的，所以编译期会要求使用final来修饰外部变量。（如果不显式的声明为final，则不允许出现修改该局部变量的操作，即<strong>隐式的final</strong>）</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lambda </tag>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
