<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ThreadLocal介绍</title>
      <link href="/archives/f3be0909.html"/>
      <url>/archives/f3be0909.html</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h2><p>ThreadLocal支持泛型，如ThreadLocal<String>,ThreadLocal是线程局部变量，它和普通变量相比，每个线程持有这个变量的副本，而且这个副本只能由当前thread使用，这就不存在多线程间之前共享的情况，那么就不存在同步的问题。ThreadLocal变量通常被<strong>private static</strong>修饰，当一个线程结束时，它所使用的所有ThreadLocal相对的实例副本都可被回收。</p><pre class="line-numbers language-[java]"><code class="language-[java]">/** * This class provides thread-local variables.  These variables differ from * their normal counterparts in that each thread that accesses one (via its * {@code get} or {@code set} method) has its own, independently initialized * copy of the variable.  {@code ThreadLocal} instances are typically private * static fields in classes that wish to associate state with a thread (e.g., * a user ID or Transaction ID). */public class ThreadLocal<T> {    ...省略  protected T initialValue() {        return null;    }    public static <S> ThreadLocal<S> withInitial(Supplier<? extends S> supplier) {        return new SuppliedThreadLocal<>(supplier);    }    public ThreadLocal() {    }    ...省略}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到ThreadLocal适用于每个线程需要自己独立的实例并且该实例需要在多个方法中使用的场景。</p><h2 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h2><p>我们需要在每个线程中维护自己独立的实例，那么可以使用Map类型来维护，使用每个线程作为key，对应的实例作为值，但是这个map不能被多个线程共享，否则它就是不安全的，所以它肯定是跟线程绑定在一起的。事实上，在Thread类中：</p><pre class="line-numbers language-[java]"><code class="language-[java]"> /* ThreadLocal values pertaining to this thread. This map is maintained     * by the ThreadLocal class. */    ThreadLocal.ThreadLocalMap threadLocals = null;    /*     * InheritableThreadLocal values pertaining to this thread. This map is     * maintained by the InheritableThreadLocal class.     */    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ThreadLocal.ThreadLocalMap的存在就是ThreadLocal的关键。<br>ThreadLocalMap是一个静态内部类，该类的Entry继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</p><pre class="line-numbers language-[java]"><code class="language-[java]"> static class Entry extends WeakReference<ThreadLocal<?>> {            /** The value associated with this ThreadLocal. */            Object value;            Entry(ThreadLocal<?> k, Object v) {                super(k);                value = v;            }        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里对键使用了弱引用，当没有强引用指向ThreadLocal变量时，它可以被GC回收，从而避免了ThreadLocal没有被回收而出现的内存泄漏的情况<br>同时需要注意的是，ThreadLocalMap中键可以被回收，但是entry却无法被移出，从而使得实例被entry引用而无法回收造成内存泄漏，解决这个问题的方法就是<strong>调用threadLocal的remove</strong>方法，把当前的threadLocal从当前线程的threadLocalMap中移出（key和value）</p><h3 id="读取实例（Get）"><a href="#读取实例（Get）" class="headerlink" title="读取实例（Get）"></a>读取实例（Get）</h3><p>get方法是用来获取threadLocal在当前线程中保存的变量副本</p><pre class="line-numbers language-[java]"><code class="language-[java]"> public T get() {        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null) {            ThreadLocalMap.Entry e = map.getEntry(this);            if (e != null) {                @SuppressWarnings("unchecked")                T result = (T)e.value;                return result;            }        }        return setInitialValue();    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，首先获取到当前线程，并通过getMap(t)方法获取到一个map</p><pre class="line-numbers language-[java]"><code class="language-[java]"> ThreadLocalMap getMap(Thread t) {        return t.threadLocals;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后通过getEntry（this）获取到&lt;key,Value&gt;键值对，this就是当前访问的ThreadLocal对象，如果获取到的entry不为null，就直接获取该entry的值，否则通过setInitialValue()方法设置初始值。</p><h3 id="设置实例（Set）"><a href="#设置实例（Set）" class="headerlink" title="设置实例（Set）"></a>设置实例（Set）</h3><p>set方法是将实例值放到threadLocalMap中</p><pre class="line-numbers language-[java]"><code class="language-[java]">public void set(T value) {        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null)            map.set(this, value);        else            createMap(t, value);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样先获取到当前线程，再获取到当前线程的ThreadLocalMap，最后通过set(this, value)添加到map中，在set(this, value)方法,调用了replaceStaleEntry（）方法将key==null的entry都设置为null，从而防止了内存泄漏。</p><h3 id="删除实例（Remove）"><a href="#删除实例（Remove）" class="headerlink" title="删除实例（Remove）"></a>删除实例（Remove）</h3><pre class="line-numbers language-[java]"><code class="language-[java]">private void remove(ThreadLocal<?> key) {            Entry[] tab = table;            int len = tab.length;            int i = key.threadLocalHashCode & (len-1);            for (Entry e = tab[i];                 e != null;                 e = tab[i = nextIndex(i, len)]) {                if (e.get() == key) {                    e.clear();                    expungeStaleEntry(i);                    return;                }            }        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在remove方法中，调用了expungeStaleEntry方法将key==null的enrty都设置为null，从而防止了内存泄漏。</p><h2 id="ThreadLocal使用场景"><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a>ThreadLocal使用场景</h2><h3 id="Session管理"><a href="#Session管理" class="headerlink" title="Session管理"></a>Session管理</h3><p>在Java Web中，Session保存了很多重要信息，我们经常通过session去获取和保存信息，有时候还需要修改sesson的信息，而且我们需要不同的线程有自己的session实例，之间互不影响，这里可以使用ThreadLocal。</p><pre class="line-numbers language-[java]"><code class="language-[java]">    private static final ThreadLocal threadSession = new ThreadLocal();    public static Session getSession() throws InfrastructureException {        Session s = (Session) threadSession.get();        try {            if (s == null) {                s = getSessionFactory().openSession();                threadSession.set(s);            }        } catch (HibernateException ex) {            throw new InfrastructureException(ex);        }        return s;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dubbo中cache"><a href="#dubbo中cache" class="headerlink" title="dubbo中cache"></a>dubbo中cache</h3><p>在dubbo的CacheFilter中,进行了请求缓存的操作：</p><pre class="line-numbers language-[java]"><code class="language-[java]">@Activate(    group = {"consumer", "provider"},    value = {"cache"})public class CacheFilter implements Filter {    private CacheFactory cacheFactory;    public CacheFilter() {    }    public void setCacheFactory(CacheFactory cacheFactory) {        this.cacheFactory = cacheFactory;    }    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {        if(this.cacheFactory != null && ConfigUtils.isNotEmpty(invoker.getUrl().getMethodParameter(invocation.getMethodName(), "cache"))) {            Cache cache = this.cacheFactory.getCache(invoker.getUrl(), invocation);            if(cache != null) {                String key = StringUtils.toArgumentString(invocation.getArguments());                Object value = cache.get(key);                if(value != null) {                    return new RpcResult(value);                }                Result result = invoker.invoke(invocation);                if(!result.hasException() && result.getValue() != null) {                    cache.put(key, result.getValue());                }                return result;            }        }        return invoker.invoke(invocation);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在RPC调用invoke方法前，会先使用请求参数判断当前线程是否刚刚发起过相同参数的调用，这个调用是在缓存中保存了的，dubbo提供了三种缓存实现</p><pre><code>threadlocal=com.alibaba.dubbo.cache.support.threadlocal.ThreadLocalCacheFactorylru=com.alibaba.dubbo.cache.support.lru.LruCacheFactoryjcache=com.alibaba.dubbo.cache.support.jcache.JCacheFactory</code></pre><p>在其中的ThreadLocalCacheFactory工厂中提供了ThreadLocalCache(Url url)构造方法，提供了ThreadLocalCache</p><pre class="line-numbers language-[java]"><code class="language-[java]">public class ThreadLocalCache implements Cache {    private final ThreadLocal<Map<Object, Object>> store = new ThreadLocal<Map<Object, Object>>() {        protected Map<Object, Object> initialValue() {            return new HashMap();        }    };    public ThreadLocalCache(URL url) {    }    public void put(Object key, Object value) {        ((Map)this.store.get()).put(key, value);    }    public Object get(Object key) {        return ((Map)this.store.get()).get(key);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ThreadLocal和线程池"><a href="#ThreadLocal和线程池" class="headerlink" title="ThreadLocal和线程池"></a>ThreadLocal和线程池</h2><p>ThreadLocal对象的生命周期和线程的生命周期一样长，线程池中的线程是复用的，所以线程的ThreadLocal会互相串来串去，所以不建议在和线程池一起使用，如果必须一起使用，建议在线程使用完成后清除到线程中绑定的threadLocal。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
            <tag> 内存泄漏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈Java内存泄漏</title>
      <link href="/archives/39e22680.html"/>
      <url>/archives/39e22680.html</url>
      
        <content type="html"><![CDATA[<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>在计算机科学中，<strong>内存泄漏</strong>指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该内存之前就失去了对该段内存的控制，从而造成了内存的浪费。（维基百科）</p><p>在Java中，设计了垃圾回收器进行自动回收垃圾，而不在需要我们手动进行内存释放，给我们编程带来了便捷，但同时也使得内存泄漏更加隐蔽。</p><h3 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h3><p>在编程过程中，我们在内存中申请一块区域进行创建对象，在使用完成之后，我们希望这块内存可以立即被回收掉，这是我们的理想情况，但是GC线程的优先级别很低，同时JVM调用GC的策略也有所不同，就存在引用在内存中包含对象的时间长于预期的存活时间的情况，这样就可能出现内存泄漏。</p><p>我们经常看到静态集合类内存泄漏的一个例子：</p><pre class="line-numbers language-[java]"><code class="language-[java]">Static Vector v = new Vector();for (int i=1;i<100;i++){    Object o = new Object();    v.add(o);    o = null;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用了for循环创建对象并把对象加入到Vector中，这里并没有什么问题，但是如果继续对Vector进行操作，而在方法结束时却没有对<strong>vector</strong>进行赋值null操作，就会出现GC无法回收这100个object对象的问题。所以需要加上</p><pre><code>v = null;</code></pre><p>下面是通过减少对象作用域来避免Java内存泄漏的典型情况(LinkedList源码)：</p><pre class="line-numbers language-[java]"><code class="language-[java]">     /**     * Unlinks non-null node x.     * 删除指定节点并返回被删除的元素值     */    E unlink(Node<E> x) {        // assert x != null;        final E element = x.item;        final Node<E> next = x.next;        final Node<E> prev = x.prev;        if (prev == null) {            //如果前一个节点为空（当前节点就是首节点），将后一个节点设置为新的首节点            first = next;        } else {            //如果前一个节点不为空，那么它的后一个节点设置为前节点的后节点            prev.next = next;            //方便GC回收            x.prev = null;        }        if (next == null) {            //如果后一个节点为空（当前节点是尾节点），将前一个节点设置为新的尾节点            last = prev;        } else {            //如果后一个节点不为空，将后节点的前节点设置为删除元素的前节点            next.prev = prev;            //方便GC回收            x.next = null;        }        x.item = null;        size--;        modCount++;        return element;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码是LinkedList删除指定节点的内部方法，我们不仅改变了前后节点的前后指向关系，还进行了赋值null的操作，方便GC回收。</p><h3 id="常见的内存泄漏情况"><a href="#常见的内存泄漏情况" class="headerlink" title="常见的内存泄漏情况"></a>常见的内存泄漏情况</h3><h4 id="静态集合类"><a href="#静态集合类" class="headerlink" title="静态集合类"></a>静态集合类</h4><p>比如HashMap，Vector等集合，这些静态变量的生命周期和程序一致，他们引用的对象不能被回收</p><h4 id="各种资源连接"><a href="#各种资源连接" class="headerlink" title="各种资源连接"></a>各种资源连接</h4><p>我们经常使用的数据库连接、网络连接、IO连接，以及使用框架的资源连接（Hibernate的SessionFacotry获取的session对象）</p><pre><code>Session session = sessionFactory.openSession();</code></pre><p>使用完成后需要进行关闭</p><pre><code>try{    session=sessionFactory.openSession();    //数据库操作}finally{    session.close();}</code></pre><h4 id="单例模式导致的内存泄漏"><a href="#单例模式导致的内存泄漏" class="headerlink" title="单例模式导致的内存泄漏"></a>单例模式导致的内存泄漏</h4><p>单例模式是一个长生命周期的对象，如果这个对象持有其他对象的引用，就很容易发生内存泄漏。</p><h4 id="内部类和外部模块的引用"><a href="#内部类和外部模块的引用" class="headerlink" title="内部类和外部模块的引用"></a>内部类和外部模块的引用</h4><p>内部类的对象隐式持有了外部模块对象，影响了外部类对象的回收，解决方法是将内部类定义为静态内部类，静态内部类不会隐式持有外部对象的引用。<br>静态内部类中引用外部类的变量必须是静态对象，存放在JVM内存模型中的方法区，从而可以直接的引用到需要的变量<br>非静态内部类中引用外部类的变量是通过隐式持有外部类对象，可以通过编译后的字节码可以看出来。</p><h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><p>通常会使用各种监听器来监听对象的相关事件，但是释放对象的时候却没有删除这些监听器</p><h3 id="如何避免发生内存泄漏"><a href="#如何避免发生内存泄漏" class="headerlink" title="如何避免发生内存泄漏"></a>如何避免发生内存泄漏</h3><h4 id="良好的编码习惯"><a href="#良好的编码习惯" class="headerlink" title="良好的编码习惯"></a>良好的编码习惯</h4><p>最简单的方法就是<strong>尽早的释放无关对象</strong>，这样让GC可以尽早回收，<br>同时我们需要注意该对象是否被监听，若是，则首先去掉监听器；当对象是一个Thread时，删除之前先调用<strong>interrupt()</strong>方法来通知线程应该中断了；代码中同时注意异常处理，是否存在相关的连接是否需要关闭等。</p><h4 id="使用测试工具"><a href="#使用测试工具" class="headerlink" title="使用测试工具"></a>使用测试工具</h4><p>可以使用检测工具来查看，比如jstack,jconsole,jmap,jstat等等</p><h4 id="使用弱引用"><a href="#使用弱引用" class="headerlink" title="使用弱引用"></a>使用弱引用</h4><p>弱引用是对一个对象的引用的持有者，在GC时，无论内存是否足够，对象均会被回收。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存泄漏 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈Java弱引用</title>
      <link href="/archives/eee3a181.html"/>
      <url>/archives/eee3a181.html</url>
      
        <content type="html"><![CDATA[<h2 id="引用概述"><a href="#引用概述" class="headerlink" title="引用概述"></a>引用概述</h2><p>在Java中，存在着四种引用类型，它们按照由强到弱依次是：强引用、软引用、弱引用、虚引用，我们可以用不用的引用来更加了灵活的控制对象的生命周期。</p><h3 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h3><p>类型共有四种，分别是：</p><ul><li>强引用（StrongReference）：最常见的引用，如果一个对象拥有强引用，那GC不会对它进行回收，虚拟机宁愿抛出OutOfMemoryError错误，也不会来回收具有强引用的对象来达到解决内存不足的目地。<br><code>（Object obj = new Object()）</code></li><li>软引用（SoftReference）：如果一个对象拥有软引用，并且内存足够，GC就不会回收它，而在内存不足时，就是回收这个对象的内存。只要GC没有回收它，该对象就可以被程序使用，可以通过软引用来实现缓存的功能<br><code>（SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(new Object())//sf就是软引用，可以通过sf.get()获取该对象，若对象被回收了，则获取到的是null）</code></li><li>弱引用（WeakReference）： 在GC时，无论内存是否足够，均会被回收，不过垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只有弱引用的对象<br><code>（WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(new Object())//wf就是弱引用，GC回收后获取到null）</code></li><li>虚引用（PhantomReference）：虚在这里的意思就是“<strong>形同虚设</strong>”，虚引用不会觉得对象的生命周期，如果一个对象仅持有虚引用，那么就和没有引用一样。虚引用主要用来跟踪垃圾回收器的活动，因为虚引用一般跟引用队列一起使用，回收对象前，将这个虚引用加入这个歌引用队列中，从而记录它指向的对象已经被回收。</li></ul><h2 id="弱引用介绍"><a href="#弱引用介绍" class="headerlink" title="弱引用介绍"></a>弱引用介绍</h2><p>WeakReference类位于java.lang.ref下：</p><pre class="line-numbers language-[java]"><code class="language-[java]">public class WeakReference<T> extends Reference<T> {    /**     * Creates a new weak reference that refers to the given object.  The new     * reference is not registered with any queue.     *     * @param referent object the new weak reference will refer to     */    public WeakReference(T referent) {        super(referent);    }    /**     * Creates a new weak reference that refers to the given object and is     * registered with the given queue.     *     * @param referent object the new weak reference will refer to     * @param q the queue with which the reference is to be registered,     *          or <tt>null</tt> if registration is not required     */    public WeakReference(T referent, ReferenceQueue<? super T> q) {        super(referent, q);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个构造方法的区别是第二个构造方法中加入了ReferenceQueue的引用队列，当这个引用被回收后，就会将其加入到这个引用队列中。</p><h3 id="WeakReference-T-referent"><a href="#WeakReference-T-referent" class="headerlink" title="WeakReference(T referent)"></a>WeakReference(T referent)</h3><p>基础类User</p><pre class="line-numbers language-[java]"><code class="language-[java]">@Data@AllArgsConstructorpublic class User{    private String name;    private int age;    @Override    protected void finalize() throws Throwable    {        System.out.println("开始GC");        super.finalize();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继承WeakReference<User>的UserRef：</p><pre class="line-numbers language-[java]"><code class="language-[java]">public class UserRef extends WeakReference<User>{    public UserRef(User referent)    {        super(referent);    }    public UserRef(User referent, ReferenceQueue<? super User> q)    {        super(referent, q);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>WeakReferenceDemo的dome1：</p><pre class="line-numbers language-[java]"><code class="language-[java]">public class WeakReferenceDemo{    public static void main(String[] args)    {        dome1();        //dome2();        //dome3();    }    private static void dome1()    {        //user是强引用，GC不回收        User user = new User("huang", 20);        UserRef userRef = new UserRef(user);        UserRef userRef2 = new UserRef(new User("zhangsan", 18));        UserRef userRef3 = new UserRef(new User("lisi", 25));        System.out.println(userRef.get());        System.out.println(userRef2.get());        System.out.println(userRef3.get());        System.out.println("-----请求GC-----");        System.gc();        try        {            Thread.sleep(1000);        } catch (InterruptedException e)        {            e.printStackTrace();        }        //回收的是User        System.out.println(userRef);        System.out.println(userRef2);        System.out.println(userRef3);        System.out.println(userRef.get());        System.out.println(userRef2.get());        System.out.println(userRef3.get());    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre><code>User(name=huang, age=20)User(name=zhangsan, age=18)User(name=lisi, age=25)-----请求GC-----开始GC开始GCcom.hq.test.UserRef@5aaa6d82Disconnected from the target VM, address: &#39;127.0.0.1:56573&#39;, transport: &#39;socket&#39;com.hq.test.UserRef@73a28541com.hq.test.UserRef@6f75e721User(name=huang, age=20)nullnull</code></pre><p>可以看到GC只回收弱引用</p><h3 id="WeakReference-T-referent-ReferenceQueue-lt-super-T-gt-q"><a href="#WeakReference-T-referent-ReferenceQueue-lt-super-T-gt-q" class="headerlink" title="WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q)"></a>WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q)</h3><p>dome2</p><pre class="line-numbers language-[java]"><code class="language-[java]"> private static void dome2()    {        ReferenceQueue queue = new ReferenceQueue();        UserRef userRef2 = new UserRef(new User("zhangsan", 18), queue);        UserRef userRef3 = new UserRef(new User("lisi", 25), queue);        System.out.println(userRef2.get());        System.out.println(userRef3.get());        Reference<? extends User> reference = null;        while ((reference = queue.poll())!=null){            //还没有GC,队列中没有值不会有输出            System.out.println("队列中的值:" + reference);        }        System.out.println("-----请求GC-----");        System.gc();        try        {            Thread.sleep(1000);        } catch (InterruptedException e)        {            e.printStackTrace();        }        System.out.println(userRef2);        System.out.println(userRef3);        System.out.println(userRef2.get());        System.out.println(userRef3.get());        while ((reference = queue.poll())!=null){            System.out.println("队列中的值:" + reference);        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在main方法中运行方法dome2</p><p>输出：</p><pre><code>User(name=zhangsan, age=18)User(name=lisi, age=25)-----请求GC-----开始GC开始GCDisconnected from the target VM, address: &#39;127.0.0.1:56582&#39;, transport: &#39;socket&#39;com.hq.test.UserRef@5aaa6d82com.hq.test.UserRef@73a28541nullnull队列中的值:com.hq.test.UserRef@5aaa6d82队列中的值:com.hq.test.UserRef@73a28541</code></pre><p>可以看到被回收的弱引用对象加到了队列中</p><pre class="line-numbers language-[java]"><code class="language-[java]">  private static void dome3()    {        ReferenceQueue queue = new ReferenceQueue();        UserRef userRef2 = new UserRef(new User("zhangsan", 18), queue);        UserRef userRef3 = new UserRef(new User("lisi", 25), queue);        System.out.println(userRef2.get());        //clear方法手动清除        userRef2.clear();        //已经被clear方法清除了,get到null值        System.out.println(userRef2.get());        System.out.println(userRef3.get());        Reference<? extends User> reference = null;        while ((reference = queue.poll())!=null){            //还没有GC,队列中没有值不会有输出            System.out.println("队列中的值:" + reference);        }        System.out.println("-----请求GC-----");        System.gc();        try        {            Thread.sleep(1000);        } catch (InterruptedException e)        {            e.printStackTrace();        }        System.out.println(userRef2);        System.out.println(userRef3);        System.out.println(userRef2.get());        System.out.println(userRef3.get());        while ((reference = queue.poll())!=null){            System.out.println("队列中的值:" + reference);        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在main方法中运行方法dome3</p><p>输出：</p><pre><code>User(name=zhangsan, age=18)nullUser(name=lisi, age=25)-----请求GC-----开始GC开始GCDisconnected from the target VM, address: &#39;127.0.0.1:56594&#39;, transport: &#39;socket&#39;com.hq.test.UserRef@5aaa6d82com.hq.test.UserRef@73a28541nullnull队列中的值:com.hq.test.UserRef@73a28541</code></pre><p>这里可以看出队列中只有一个值了</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda简介</title>
      <link href="/archives/14747.html"/>
      <url>/archives/14747.html</url>
      
        <content type="html"><![CDATA[<h2 id="lambda概述"><a href="#lambda概述" class="headerlink" title="lambda概述"></a>lambda概述</h2><p>同其他编程语言相比，在Java8之前，Java缺少了高效的并行操作，使得编写并发程序的代码非常臃肿，所以在Java8中，借鉴了函数式编程的思想引入了lambda表达式，lambda是一种匿名函数。通俗点讲，它没有声明的方法，也就没有访问的修饰符、返回值声明和名字，让代码更加紧凑高效和易于阅读。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>(parameters)-&gt;{statements} </p><p>or</p><p>(parameters)-&gt;statements</p><p>or</p><p> (parameters)-&gt;expression</p><p>eg：</p><pre class="line-numbers language-[java]"><code class="language-[java]">//无参函数() -> 8；//两个参数函数，返回它们的和,一行代码的话可以去掉花括号{}(a，b) -> a+b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lambda使用"><a href="#lambda使用" class="headerlink" title="lambda使用"></a>lambda使用</h2><p>我们可以使用lambda表达式来替换匿名类，这里使用Runable来举例：</p><pre class="line-numbers language-[java]"><code class="language-[java]">//java8之前new Thread(new Runnable()        {            @Override            public void run()            {                System.out.println("hello world");            }        }).start();//java8new Thread(()-> System.out.println("hello world")).start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以明显的看到代码精简了很多，而且更加方便阅读，在这里我们看不到run方法了，这是因为在Runable接口下只有一个方法的原因，如果有多个，匿名函数是没有办法来区分的。</p><pre class="line-numbers language-[java]"><code class="language-[java]">@FunctionalInterfacepublic interface Runnable {    public abstract void run();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用<strong>@FunctionalInterface</strong>来声明该接口是函数式接口，就是说在这个接口中<strong>只能有一个抽象方法</strong>，如果我们在接口中定义了两个抽象方法，开发工具会对编译级错误检查进行报错的。我们可以利用@FunctionalInterface注解在多个接口的大型项目中控制接口，让其无法添加其他的抽象方法。<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://res.cloudinary.com/dikqccyyc/image/upload/v1577881736/functionalInterface_af5vfo.png" alt="编译级错误"></p><p>JDK中函数式接口例子：</p><ul><li>java.lang.Runable</li><li>java.util.concurrent.Callable</li><li>java.util.Comparator</li><li>java.util.function包下的接口,如Function，Consumer，Predicate，Supplier</li></ul><h3 id="不要将lambda表达式视为内部类"><a href="#不要将lambda表达式视为内部类" class="headerlink" title="不要将lambda表达式视为内部类"></a>不要将lambda表达式视为内部类</h3><p>在前面提到的lambda代替Runable接口中，我们替换了内部类，但是两者在范围上是不同的。</p><p>当我们使用内部类时，它将创建一个新的作用域，你可以通过实例化具有相同名称的新局部变量来从封闭范围中隐藏局部变量，也可以使用this来作为实例的引用。而lambda中，你无法拥有一个新的作用域。<br>为什么呢？</p><p>这是因为匿名内部类仍然是一个类，通过javac可以看到会将匿名内部类重新编译为一个class文件，只是这个类名不需要人为指定，编译器会自动命名。</p><p>lambda表达式是通过invokedynamic指令实现，不会产生新的类。</p><h3 id="使用方法引用"><a href="#使用方法引用" class="headerlink" title="使用方法引用"></a>使用方法引用</h3><p>方法引用不是方法调用，方法引用是 lambda 表达式的语法糖，任何用方法引用的地方都可由lambda表达式替换，但是不是所有的lambda表达式都可以使用方法引用来替换。（范围有区别）</p><p>静态方法引用  类名::静态方法名<br>实例方法引用  对象名(引用名) :: 实例方法名<br>类方法引用  类名::实例方法名<br>构造方法引用  类名::new</p><p>所以lambda表达式：</p><pre class="line-numbers language-[java]"><code class="language-[java]">a -> a.toLowerCase();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以替换为</p><pre class="line-numbers language-[java]"><code class="language-[java]">//类名::实例方法名String :: toLowerCase<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="外部变量使用final修饰"><a href="#外部变量使用final修饰" class="headerlink" title="外部变量使用final修饰"></a>外部变量使用final修饰</h3><p>在Java中方法的调用是值传递的，lambda也不例外，我们在lambda表达式中对变量的操作都是基于原变量的副本，不会影响到原变量的值的。</p><p>如果我们在lambda表达式外部变量不用final修饰，那么开发者会认为外部变量的值可以在lambda中被改变，而实际是不可能的，所以编译期会要求使用final来修饰外部变量。（如果不显式的声明为final，则不允许出现修改该局部变量的操作，即<strong>隐式的final</strong>）</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lambda </tag>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
