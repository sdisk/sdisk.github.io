<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>lambda简介</title>
      <link href="/lambda%E7%AE%80%E4%BB%8B.html"/>
      <url>/lambda%E7%AE%80%E4%BB%8B.html</url>
      
        <content type="html"><![CDATA[<h2 id="lambda概述"><a href="#lambda概述" class="headerlink" title="lambda概述"></a>lambda概述</h2><p>同其他编程语言相比，在Java8之前，Java缺少了高效的并行操作，使得编写并发程序的代码非常臃肿，所以在Java8中，借鉴了函数式编程的思想引入了lambda表达式，lambda是一种匿名函数。通俗点讲，它没有声明的方法，也就没有访问的修饰符、返回值声明和名字，让代码更加紧凑高效和易于阅读。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>(parameters)-&gt;{statements} </p><p>or</p><p>(parameters)-&gt;statements</p><p>or</p><p> (parameters)-&gt;expression</p><p>eg：</p><pre><code>//无参函数() -&gt; 8；//两个参数函数，返回它们的和,一行代码的话可以去掉花括号{}(a，b) -&gt; a+b;</code></pre><h2 id="lambda使用"><a href="#lambda使用" class="headerlink" title="lambda使用"></a>lambda使用</h2><p>我们可以使用lambda表达式来替换匿名类，这里使用Runable来举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//java8之前</span><br><span class="line">new Thread(new Runnable()</span><br><span class="line">        {</span><br><span class="line">            @Override</span><br><span class="line">            public void run()</span><br><span class="line">            {</span><br><span class="line">                System.out.println("hello world");</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">//java8</span><br><span class="line">new Thread(()-&gt; System.out.println("hello world")).start();</span><br></pre></td></tr></tbody></table></figure><p>可以明显的看到代码精简了很多，而且更加方便阅读，在这里我们看不到run方法了，这是因为在Runable接口下只有一个方法的原因，如果有多个，匿名函数是没有办法来区分的。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable {</span><br><span class="line">    /**</span><br><span class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class="line">     * to create a thread, starting the thread causes the object's</span><br><span class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class="line">     * thread.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class="line">     * take any action whatsoever.</span><br><span class="line">     *</span><br><span class="line">     * @see     java.lang.Thread#run()</span><br><span class="line">     */</span><br><span class="line">    public abstract void run();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们使用<strong>@FunctionalInterface</strong>来声明该接口是函数式接口，就是说在这个接口中<strong>只能有一个抽象方法</strong>，如果我们在接口中定义了两个抽象方法，开发工具会对编译级错误检查进行报错的。我们可以利用@FunctionalInterface注解在多个接口的大型项目中控制接口，让其无法添加其他的抽象方法。<br><img src="https://res.cloudinary.com/dikqccyyc/image/upload/v1577881736/functionalInterface_af5vfo.png" alt="编译级错误"></p><p>JDK中函数式接口例子：</p><ul><li>java.lang.Runable</li><li>java.util.concurrent.Callable</li><li>java.util.Comparator</li><li>java.util.function包下的接口,如Function，Consumer，Predicate，Supplier</li></ul><h3 id="不要将lambda表达式视为内部类"><a href="#不要将lambda表达式视为内部类" class="headerlink" title="不要将lambda表达式视为内部类"></a>不要将lambda表达式视为内部类</h3><p>在前面提到的lambda代替Runable接口中，我们替换了内部类，但是两者在范围上是不同的。</p><p>当我们使用内部类时，它将创建一个新的作用域，你可以通过实例化具有相同名称的新局部变量来从封闭范围中隐藏局部变量，也可以使用this来作为实例的引用。而lambda中，你无法拥有一个新的作用域。<br>为什么呢？</p><p>这是因为匿名内部类仍然是一个类，通过javac可以看到会将匿名内部类重新编译为一个class文件，只是这个类名不需要人为指定，编译器会自动命名。</p><p>lambda表达式是通过invokedynamic指令实现，不会产生新的类。</p><h3 id="使用方法引用"><a href="#使用方法引用" class="headerlink" title="使用方法引用"></a>使用方法引用</h3><p>方法引用不是方法调用，方法引用是 lambda 表达式的语法糖，任何用方法引用的地方都可由lambda表达式替换，但是不是所有的lambda表达式都可以使用方法引用来替换。（范围有区别）</p><p>静态方法引用  类名::静态方法名<br>实例方法引用  对象名(引用名) :: 实例方法名<br>类方法引用  类名::实例方法名<br>构造方法引用  类名::new</p><p>所以lambda表达式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; a.toLowerCase();</span><br></pre></td></tr></tbody></table></figure><p>可以替换为</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//类名::实例方法名</span><br><span class="line">String :: toLowerCase</span><br></pre></td></tr></tbody></table></figure><h3 id="外部变量使用final修饰"><a href="#外部变量使用final修饰" class="headerlink" title="外部变量使用final修饰"></a>外部变量使用final修饰</h3><p>在Java中方法的调用是值传递的，lambda也不例外，我们在lambda表达式中对变量的操作都是基于原变量的副本，不会影响到原变量的值的。</p><p>如果我们在lambda表达式外部变量不用final修饰，那么开发者会认为外部变量的值可以在lambda中被改变，而实际是不可能的，所以编译期会要求使用final来修饰外部变量。（如果不显式的声明为final，则不允许出现修改该局部变量的操作，即<strong>隐式的final</strong>）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lambda java8 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
